class AttackRunner extends GraphicsObject{#arrows;#attackTimeQueue;#attackManager;#player;#hud;constructor(e,t,a){super(),this.#arrows=[],this.#attackTimeQueue=[2e3],this.#player=e,this.#hud=t,this.#attackManager=new AttackManager(a)}#addAttackArrows(a){var r=this.#attackTimeQueue[0]||0,s=a.clockwiseShift,i=Math.floor(4*Math.random()),h=a.arrows.length;for(let t=0;t<h;++t){var o=a.arrows[t];let e=o.direction;"?"===e?e=Math.floor(4*Math.random()):(e=parseInt(e),s&&(e=(e+i)%4));var n=o.targetTime+r;this.#arrows.push(new Arrow(e,o.reversed,n,o.speed,t===h-1))}}addNextAttack(){2<=this.#attackTimeQueue.length&&(e=this.#attackTimeQueue[0],this.#attackTimeQueue.shift(),this.#attackTimeQueue[0]+=e);var e=this.#attackManager.getNextAttack();null!=e&&(this.#addAttackArrows(e),this.#attackTimeQueue.push(e.nextTime))}removeAllArrows(){for(let e=0;e<this.#arrows.length;++e)Main.runner.gameplayStage.removeChild(this.#arrows[e].sprite);this.#arrows=[]}arrowsEmpty(){return 0===this.#arrows.length}reset(){this.#attackTimeQueue=[2e3],this.#attackManager.reset()}#arrowShieldSameSide(e){e=(e.direction+(e.reversed?2:0))%4;return this.#player.shieldDir===e}#removeArrow(e,t){e.last&&this.#hud.incrementAttackNumber(),Main.runner.gameplayStage.removeChild(e.sprite),this.#arrows.splice(t,1)}update(t){for(let e=this.#arrows.length-1;0<=e;--e){const a=this.#arrows[e];a.update(t),a.targetTime/1e3*a.speed<-Player.shieldDistance+Player.heartDistance?(this.#player.takeDamage(),this.#removeArrow(a,e)):a.targetTime<=0&&this.#arrowShieldSameSide(a)&&(Main.runner.assetManager.getAudio("arrowBlockedSfx").play(),this.#player.hitShield(),this.#removeArrow(a,e))}0!==this.#attackTimeQueue.length&&(this.#attackTimeQueue[0]-=t,this.#attackTimeQueue[0]<=0&&this.addNextAttack())}get numAttacks(){return this.#attackManager.numAttacks}}